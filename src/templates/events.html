<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Swarm Autoscaler - Scale Events</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    .controls { margin: 8px 0 16px; display: flex; gap: 8px; align-items: center; }
    input, select, button { padding: 6px 8px; }
    table { border-collapse: collapse; width: 100%; font-size: 12px; }
    th, td { border-bottom: 1px solid #eee; padding: 6px 8px; text-align: left; }
    .up { color: #127a1b; font-weight: 600; }
    .down { color: #b00020; font-weight: 600; }
    #chart { width: 100%; height: 160px; border: 1px solid #eee; margin: 12px 0; }
  </style>
  </head>
  <body>
    <h1>Scale Events</h1>
    <div class="controls">
      <label>Service: <input id="svc" placeholder="(all)" /></label>
      <label>Limit: <input id="limit" type="number" value="200" min="1" max="10000" /></label>
      <button id="refresh">Refresh</button>
      <button id="clear">Clear</button>
      <span id="status" style="margin-left:auto;color:#666;"></span>
    </div>
    <canvas id="chart"></canvas>
    <table>
      <thead>
        <tr>
          <th>Time</th><th>Service</th><th>Metric</th><th>Old</th><th>New</th><th>Î”</th><th>Dir</th><th>Reason</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>

    <script>
    const rowsEl = document.getElementById('rows');
    const svcEl = document.getElementById('svc');
    const limitEl = document.getElementById('limit');
    const statusEl = document.getElementById('status');
    const chartEl = document.getElementById('chart');
    const ctx = chartEl.getContext('2d');

    function fmtTs(ts){
      const d = new Date(ts*1000);
      return d.toISOString().replace('T',' ').replace('Z','');
    }

    function renderTable(events){
      rowsEl.innerHTML = events.slice().reverse().map(e=>{
        const cls = e.delta>0? 'up' : (e.delta<0? 'down' : '');
        return `<tr>
          <td>${fmtTs(e.ts)}</td>
          <td>${e.service}</td>
          <td>${e.metric || ''}</td>
          <td>${e.old}</td>
          <td>${e.new}</td>
          <td class="${cls}">${e.delta}</td>
          <td class="${cls}">${e.direction}</td>
          <td>${e.reason || ''}</td>
        </tr>`;
      }).join('');
    }

    function renderChart(events){
      const W = chartEl.width = chartEl.clientWidth || 800;
      const H = chartEl.height = 220;
      ctx.clearRect(0,0,W,H);

      const data = events.slice(-200).reverse(); // chronological
      if(!data.length) return;

      // Group by service and use current replicas (new) as value
      const series = new Map();
      let tMin = Infinity, tMax = -Infinity; let yMin = Infinity, yMax = -Infinity;
      for(const e of data){
        const svc = e.service;
        if(!series.has(svc)) series.set(svc, []);
        const ts = e.ts, y = Number(e.new);
        series.get(svc).push({ts, y});
        if(ts < tMin) tMin = ts; if(ts > tMax) tMax = ts;
        if(y < yMin) yMin = y; if(y > yMax) yMax = y;
      }
      if(!isFinite(tMin) || tMin === tMax) { tMin = tMax - 1; }
      if(!isFinite(yMin) || yMin === yMax) { yMin = yMin-1; yMax = yMax+1; }

      // chart padding
      const PL = 48, PR = 12, PT = 12, PB = 28;
      const PW = W - PL - PR, PH = H - PT - PB;

      // axes
      ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(PL, PT); ctx.lineTo(PL, PT+PH); ctx.stroke(); // y
      ctx.beginPath(); ctx.moveTo(PL, PT+PH); ctx.lineTo(PL+PW, PT+PH); ctx.stroke(); // x

      // y ticks (min/mid/max)
      const yMid = (yMin + yMax)/2;
      const yTicks = [yMax, yMid, yMin];
      ctx.fillStyle = '#666'; ctx.font = '12px system-ui, sans-serif'; ctx.textAlign = 'right';
      function yToPx(v){ return PT + PH - ((v - yMin)/(yMax - yMin))*PH; }
      for(const v of yTicks){
        const y = yToPx(v);
        ctx.strokeStyle = '#eee'; ctx.beginPath(); ctx.moveTo(PL, y); ctx.lineTo(PL+PW, y); ctx.stroke();
        ctx.fillText(String(Math.round(v)), PL-6, y+1);
      }

      // x labels (first/last time)
      const fmt = ts=> new Date(ts*1000).toLocaleTimeString();
      ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillStyle = '#666';
      ctx.fillText(fmt(tMin), PL, PT+PH+6);
      ctx.fillText(fmt(tMax), PL+PW, PT+PH+6);

      // Color palette
      const palette = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'];
      const svcNames = Array.from(series.keys()).sort();
      const colorOf = s => palette[svcNames.indexOf(s) % palette.length];

      // Plot each service line and collect pixel points for hover
      const seriesPts = [];
      for(const svc of svcNames){
        const pts = series.get(svc).sort((a,b)=>a.ts-b.ts);
        ctx.strokeStyle = colorOf(svc); ctx.lineWidth = 1.8;
        ctx.beginPath();
        const pix = pts.map((p,i)=>{
          const x = PL + ((p.ts - tMin)/(tMax - tMin))*PW;
          const y = yToPx(p.y);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
          return {x,y, ts:p.ts, val:p.y, svc};
        });
        ctx.stroke();
        seriesPts.push({svc, color: colorOf(svc), pts: pix});
      }

      // Legend
      const lh = 16; const boxW = 10; const pad = 6;
      let lx = PL+4, ly = PT+4;
      ctx.font = '12px system-ui, sans-serif'; ctx.textAlign='left'; ctx.textBaseline='middle';
      for(const svc of svcNames){
        ctx.fillStyle = colorOf(svc);
        ctx.fillRect(lx, ly, boxW, boxW);
        ctx.fillStyle = '#333';
        ctx.fillText(svc, lx+boxW+6, ly+boxW/2);
        lx += Math.min(180, ctx.measureText(svc).width + boxW + 28);
        if(lx > PL+PW-160){ lx = PL+4; ly += lh+4; }
      }

      // Save state for hover rendering
      window._chartState = { W,H, PL,PT,PW,PH, tMin,tMax, yMin,yMax, seriesPts };
    }

    async function load(){
      const svc = svcEl.value.trim();
      const limit = parseInt(limitEl.value||'200',10);
      const url = new URL(window.location.origin + '/api/events');
      url.searchParams.set('limit', String(limit));
      if(svc) url.searchParams.set('service', svc);
      const t0 = performance.now();
      const res = await fetch(url);
      const data = await res.json();
      const dt = (performance.now()-t0).toFixed(0);
      statusEl.textContent = `events=${data.events.length} (${dt}ms)`;
      renderTable(data.events);
      window._lastEvents = data.events;
      renderChart(window._lastEvents);
    }

    document.getElementById('refresh').onclick = load;
    document.getElementById('clear').onclick = async () => {
      const svc = svcEl.value.trim();
      const url = new URL(window.location.origin + '/api/events/clear');
      if(svc) url.searchParams.set('service', svc);
      const res = await fetch(url, { method: 'POST' });
      if(res.ok){ await load(); }
    };
    setInterval(load, 5000);
    load();

    // Hover interaction: crosshair + tooltip for nearest point
    function redrawWithOverlay(hit){
      if(!window._lastEvents) return;
      renderChart(window._lastEvents);
      if(!hit) return;
      const {x,y, svc, ts, val, color} = hit;
      // crosshair
      ctx.strokeStyle = '#bbb'; ctx.lineWidth = 1; ctx.setLineDash([4,3]);
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, chartEl.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(chartEl.width, y); ctx.stroke();
      ctx.setLineDash([]);
      // point
      ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
      // tooltip
      const text = `${svc}  |  replicas=${val}  |  ${new Date(ts*1000).toLocaleString()}`;
      ctx.font = '12px system-ui, sans-serif';
      const tw = ctx.measureText(text).width + 16, th = 22;
      let tx = x + 10, ty = y - th - 8;
      if(tx + tw > chartEl.width) tx = x - tw - 10;
      if(ty < 4) ty = y + 12;
      ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.strokeStyle = '#ccc';
      ctx.fillRect(tx, ty, tw, th); ctx.strokeRect(tx, ty, tw, th);
      ctx.fillStyle = '#333'; ctx.textBaseline='middle'; ctx.textAlign='left';
      ctx.fillText(text, tx+8, ty+th/2);
    }

    function nearestPoint(mx, my){
      const st = window._chartState; if(!st) return null;
      let best=null, bestD=Infinity;
      for(const s of st.seriesPts){
        for(const p of s.pts){
          const dx = p.x - mx, dy = p.y - my; const d = Math.hypot(dx, dy);
          if(d < bestD){ bestD = d; best = {...p, color:s.color}; }
        }
      }
      return bestD <= 20 ? best : null; // 20px snap radius
    }

    chartEl.addEventListener('mousemove', (e)=>{
      const r = chartEl.getBoundingClientRect();
      const mx = e.clientX - r.left; const my = e.clientY - r.top;
      redrawWithOverlay(nearestPoint(mx,my));
    });
    chartEl.addEventListener('mouseleave', ()=>{ redrawWithOverlay(null); });
    </script>
  </body>
  </html>


